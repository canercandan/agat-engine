/*
** This file parses the agat code and fill a tree out contening all the structure
** before to be generated by the Pretty Printer.
**
** Refer to the prettyPrinter.cws file to understand how the created tree is used.
*/

#explicitCopy
#noCase

/*
** The start point
*/
start ::=
  [
#ignore(XML)
#try
   [
    XMLText(this.agat.block)
#continue
#empty
    ]
#catch (sError)
   | => traceLine("sError: " + sError);
   ]
  ;

/*
** Can be either a start of marker or static text.
**
** Using the XML-Like style for the makers and a version less heavy
** to write a code quickly.
*/
XMLText(myBlock : node) ::=
  [
   [#!ignore [~'<']+]:text => insert myBlock.body["TEXT"] = text;
   |
   [!"</" '<' [IDENTIFIER:sTag
	       XMLNextOfTag<toUpperString(sTag)>(myBlock)] #continue]
   ]*
  ;

/*
** Template by default for a content of marker.
*/
XMLNextOfTag<T>(myBlock : node) ::=
  [
   => traceLine("Tag [" + T + "] not defined yet!");
   => treeInsertBlock(myBlock, T);
   => localref	theBlock = myBlock[T];
#continue XMLEndOfTag(T, theBlock.block)
   ]
  ;

/*
** Can write a HTML, CSS, PHP, ASP and WIKI content.
**
** XML-Like style: <write lang="wiki"/>
** Less heavy style: <write wiki/>
**
** Without the lang attribute the default language used is WIKI.
*/
XMLNextOfTag<"WRITE">(myBlock : node) ::=
  [
   => local	lang;
   [XMLAttribute("LANG", lang) | LITERAL(lang)]? #continue
   '>' #continue
   => local	sTag = "WRITE";
   [#!ignore [~["</" #readText(sTag) '>']]+]:write
   => {
     lang = toUpperString(lang);
     pushItem myBlock.body = write;
     localref	theBody = myBlock.body#back;

     switch (lang)
       {
       case "HTML": break;
       case "CSS": break;
       case "PHP":
	 if (equalTrees(myBlock#parent#parent#parent, this.agat) == false)
	   treeSwitchSectionTo(myBlock#parent#parent#parent, "PHP", ".php");
	 else
	   treeSwitchAllSectionsTo(this.agat.section, "PHP", ".php");
	 theBody = "<?php\n" + theBody + "?>\n";
	 break;
       case "ASP":
	 if (equalTrees(myBlock#parent#parent#parent, this.agat) == false)
	   treeSwitchSectionTo(myBlock#parent#parent#parent, "ASP", ".asp");
	 else
	   treeSwitchAllSectionsTo(this.agat.section, "ASP", ".asp");
	 theBody = "<%\n" + theBody + "%>\n";
	 break;
       default:
	 lang = "WIKI";
	 treeInsertWikiCode(myBlock);
	 break;
       }

     insert theBody.type = lang;
   }
#continue "</" #readText(sTag) '>'
   ]
  ;

/*
** Definition with section tag of all the sections wished in the web site.
**
** XML-Like style: <section name="NAME" title="TITLE"/>
** Less heavy style: <section NAME TITLE/>
*/
XMLNextOfTag<"SECTION">(myBlock : node) ::=
  [
   => local	sTag = "SECTION";
   => localref theBlock = this.agat.section;
   => local	name;
   => local	title;
   [[XMLAttribute("CALLED", name) |
     XMLAttribute("TITLE", title)]+
    | [LITERAL(name) [LITERAL(title)]?]?]
   => local	key = toUpperString(name);
   => insert theBlock.block[key];
   => localref	theSection = theBlock.block[key];
   => {
     insert theSection.name = name;
     insert theSection.type = this.agat.section.default_type;
     insert theSection.extension = this.agat.section.default_extension;
     if (title != "")
       insert theSection.title = title;
     else
       insert theSection.title = name;
   }
#continue XMLEndOfTag(sTag, theSection.block)
   ]
  ;

/*
** Definition of the website layout.
**
** Can be either an horizontal layout or a vertical layout.
*/
XMLNextOfTag<"LAYOUT">(myBlock : node) ::= Layout("LAYOUT", this.agat.layout);
XMLNextOfTag<"HORIZONTAL">(myBlock : node) ::= HorizontalVertical("HORIZONTAL", myBlock);
XMLNextOfTag<"VERTICAL">(myBlock : node) ::= HorizontalVertical("VERTICAL", myBlock);

Layout(sTag : value, myBlock : node) ::=
  [
   => local	name;
   => local	width;
   => local	height;
   [[XMLAttribute("CALLED", name) |
     XMLAttribute("HEIGHT", height) |
     XMLAttribute("WIDTH", width)]+
    | [LITERAL(name) [LITERAL(width) [LITERAL(height)]?]?]?]
   => {
     if (name != "")
       insert myBlock.name = name;
     else
       insert myBlock.name = "main";
     insert myBlock.width = width;
     insert myBlock.height = height;
     insert myBlock.type = sTag;
   }
#continue XMLEndOfTag(sTag, myBlock.block)
   ]
  ;

HorizontalVertical(sTag : value, myBlock : node) ::=
  [
   => local	name;
   => local	width;
   => local	height;
   [[XMLAttribute("CALLED", name) |
     XMLAttribute("HEIGHT", height) |
     XMLAttribute("WIDTH", width)]+
    | [LITERAL(name) [LITERAL(width) [LITERAL(height)]?]?]?]
   => local	key = toUpperString(name);
   => treeInsertBlock(myBlock, key);
   => localref	theBlock = myBlock[key];
   => {
     if (name == "")
       traceLine("The " + sTag + " must have a name!");
     insert theBlock.name = name;
     insert theBlock.width = width;
     insert theBlock.height = height;
     insert theBlock.type = sTag;
   }
#continue XMLEndOfTag(sTag, theBlock.block)
   ]
  ;

/*
** The first tag keeped on the top of the agat code.
**
** XML-Like style:
** <header domain="DOMAIN_NAME" web="WEB_SERVER"
**  port="PORT" default_username="DEFAULT_USERNAME"
**  default_password="DEFAULT_PASSWORD"/>
** Less heavy style:
** <header DOMAIN_NAME WEB_SERVER PORT DEFAULT_USERNAME DEFAULT_PASSWORD/>
*/
XMLNextOfTag<"HEADER">(myBlock : node) ::=
  [
   => local	sTag = "HEADER";
   [[XMLAttribute("DOMAIN", this.agat.header.domain) |
     XMLAttribute("WEB", this.agat.header.web) |
     XMLAttribute("HOST", this.agat.header.host) |
     XMLAttribute("PORT", this.agat.header.port) |
     XMLAttribute("DEFAULT_USERNAME", this.agat.header.default_username) |
     XMLAttribute("DEFAULT_PASSWORD", this.agat.header.default_password)]+
    | [LITERAL(this.agat.header.domain)
       [LITERAL(this.agat.header.web)
	[LITERAL(this.agat.header.host)
	 [LITERAL(this.agat.header.port)
	  [LITERAL(this.agat.header.default_username)
	   [LITERAL(this.agat.header.default_password)
	    ]?]?]?]?]?]?]
#continue XMLEndOfTag(sTag, myBlock)
   ]
  ;

/*
** Calling an existing layout to fill it out.
*/
XMLNextOfTag<"CALL-LAYOUT">(myBlock : node) ::=
  [
   => local	sTag = "CALL-LAYOUT";
   => local	name;
   [XMLAttribute("WITH", name) | LITERAL(name)]
   => local	key = toUpperString(name);
   => treeInsertBlock(myBlock, key);
   => localref	theBlock = myBlock[key];
   => insert theBlock.name = name;
   => insert theBlock.type = sTag;
#continue XMLEndOfTag(sTag, theBlock.block)
   ]
  ;

/*
** Inclusion of files
*/
XMLNextOfTag<"INCLUDE">(myBlock : node) ::=
  [
   => local	sTag = "INCLUDE";
   => local	path;
   [XMLAttribute("PATH", path) | LITERAL(path)]
   => path = getWorkingPath() + path;
   => local	pathOut = replaceString(".agat", ".out", path);
   => translate("./agat.cwp", this, path, pathOut);
#continue XMLEndOfTag(sTag, myBlock)
   ]
  ;

/*
** Creating a template
*/
XMLNextOfTag<"TEMPLATE">(myBlock : node) ::=
  [
   => local	sTag = "TEMPLATE";
   => local	name;
   [XMLAttribute("CALLED", name) | LITERAL(name)]
   => local	key = toUpperString(name);
   => insert this.agat.template[key].name = name;
   => localref	theBlock = this.agat.template[key];
   => insert theBlock.block;
#continue XMLEndOfTag(sTag, theBlock.block)
   ]
  ;

/*
** Calling a template
*/
XMLNextOfTag<"CALL-TEMPLATE">(myBlock : node) ::=
  [
   => local	sTag = "CALL-TEMPLATE";
   => local	name;
   [XMLAttribute("WITH", name) | LITERAL(name)]
   => {
     local	key = toUpperString(name);
     localref	theBlock = this.agat.template[key].block.body;
     foreach var in theBlock
     {
       pushItem myBlock.body;
       ref myBlock.body#back = var;
     }
   }
#continue XMLEndOfTag(sTag, myBlock)
   ]
  ;

/*
** Calling a variable in the database.
*/
XMLNextOfTag<"VARIABLE">(myBlock : node) ::=
  [
   => local	sTag = "VARIABLE";
   => local	name;
   [XMLAttribute("CALLED", name) | LITERAL(name)]
   => {
     if (equalTrees(myBlock#parent#parent#parent, this.agat) == false)
       treeSwitchSectionTo(myBlock#parent#parent#parent, "PHP", ".php");
     else
       treeSwitchAllSectionsTo(this.agat.section, "PHP", ".php");
     local	key = toUpperString(name);
     insert this.agat.variable[key].name = name;
     localref	theVar = this.agat.variable[key];
     insert theVar.type = sTag;
     pushItem myBlock.body;
     ref myBlock.body#back = theVar;
   }
#continue XMLEndOfTag(sTag, myBlock)
   ]
  ;

/*
** Calling an image in the database.
*/
XMLNextOfTag<"IMAGE">(myBlock : node) ::=
  [
   => local	sTag = "IMAGE";
   => local	name;
   [XMLAttribute("CALLED", name) | LITERAL(name)]
   => {
     if (equalTrees(myBlock#parent#parent#parent, this.agat) == false)
       treeSwitchSectionTo(myBlock#parent#parent#parent, "PHP", ".php");
     else
       treeSwitchAllSectionsTo(this.agat.section, "PHP", ".php");
     local	key = toUpperString(name);
     insert this.agat.image[key].name = name;
     localref	theImg = this.agat.image[key];
     insert theImg.type = sTag;
     pushItem myBlock.body;
     ref myBlock.body#back = theImg;
   }
#continue XMLEndOfTag(sTag, myBlock)
   ]
  ;

/*
** Calling a video in the database.
*/
XMLNextOfTag<"VIDEO">(myBlock : node) ::=
  [
   => local	sTag = "VIDEO";
   => local	name;
   [XMLAttribute("CALLED", name) | LITERAL(name)]
   => {
     if (equalTrees(myBlock#parent#parent#parent, this.agat) == false)
       treeSwitchSectionTo(myBlock#parent#parent#parent, "PHP", ".php");
     else
       treeSwitchAllSectionsTo(this.agat.section, "PHP", ".php");
     local	key = toUpperString(name);
     insert this.agat.video[key].name = name;
     localref	theVid = this.agat.video[key];
     insert theVid.type = sTag;
     pushItem myBlock.body;
     ref myBlock.body#back = theVid;
   }
#continue XMLEndOfTag(sTag, myBlock)
   ]
  ;

/*
** Forum tag in order to generate a forum into the project
**
** XML-Like style:
** <forum type="FORUM_TYPE"/>
** Less heavy style:
** <header FORUM_TYPE/>
*/
XMLNextOfTag<"FORUM">(myBlock : node) ::=
  [
   => local	sTag = "FORUM";
   => local	type;
   [XMLAttribute("TYPE", type) | LITERAL(type)]
   => insert this.agat.forum = type;
#continue XMLEndOfTag(sTag, myBlock)
   ]
  ;

/*
** End of marker can also have a XMLText.
*/
XMLEndOfTag(sTag : value, myBlock : node) ::=
  [
   ['>' XMLText(myBlock) "</" #readText(sTag) '>'] | "/>" | '>'
   ]
  ;

/*
** Attribute of markers
*/
XMLAttribute(key : value, value : node) ::=
  [
   [#readText(key) #continue
    ['=' #continue [LITERAL(value)]]?]
   ]
  ;

/*
** Some useful rules
*/
IDENTIFIER ::= #!ignore ['A'..'Z'][':' | 'A'..'Z' | '0'..'9' | '-']+;
LITERAL(value : node) ::= #!ignore [STRING_LITERAL(value) | WORD_LITERAL(value)];
STRING_LITERAL(value : node) ::= #!ignore '\"' [[~'\"']*]:value '\"';
WORD_LITERAL(value : node) ::= #!ignore [[~[[['/']? '>'] | ' ' | '\t']]+]:value;
EOL ::= ['\r']? '\n';
